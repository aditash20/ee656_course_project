import numpy as np
import pandas as pd
from mrmr import mrmr_classif
import os
import joblib # A good choice for saving Python objects like lists/models

# --- Configuration ---
# Number of top features to select, as per the paper's recommendation
NUM_FEATURES_TO_SELECT = 25

# Input files (should be generated by your full feature extraction pipeline)
FULL_FEATURES_FILE = 'all_features.npy'
FULL_LABELS_FILE = 'all_labels.npy'

# Output files
# The paper suggests the name "Feature_Select". Let's use a descriptive name.
# We'll save the indices, which is what's needed for future use.
SELECTED_INDICES_FILE = 'Feature_Select_mRMR_25.pkl'
REDUCED_DATASET_FILE = 'selected_features_25.npy'

# --- Main Script Logic ---

def select_and_save_best_features(k):
    """
    Loads the full feature set, performs mRMR selection for the top 'k' features,
    and saves the selected indices and the reduced dataset.
    """
    print(f"--- mRMR Feature Selection (Top {k}) ---")

    # 1. Check for and load the full dataset
    if not os.path.exists(FULL_FEATURES_FILE) or not os.path.exists(FULL_LABELS_FILE):
        print(f"Error: Input files not found!")
        print(f"Please create '{FULL_FEATURES_FILE}' and '{FULL_LABELS_FILE}' first.")
        # Create dummy files for demonstration if they don't exist
        print("Creating dummy files for this run...")
        num_samples, num_features = 200, 286
        dummy_X = np.random.rand(num_samples, num_features)
        dummy_y = np.random.randint(0, 8, num_samples)
        np.save(FULL_FEATURES_FILE, dummy_X)
        np.save(FULL_LABELS_FILE, dummy_y)
        print("Dummy files created. Please replace them with your real data.")

    print(f"Loading data from '{FULL_FEATURES_FILE}' and '{FULL_LABELS_FILE}'...")
    X_full = np.load(FULL_FEATURES_FILE)
    y = np.load(FULL_LABELS_FILE)
    print(f"Data loaded. Shapes: X={X_full.shape}, y={y.shape}")

    # 2. Prepare data for the mrmr library (requires pandas DataFrame)
    # Create generic column names like 'f_0', 'f_1', ..., 'f_285'
    feature_names = [f'f_{i}' for i in range(X_full.shape[1])]
    X_df = pd.DataFrame(X_full, columns=feature_names)
    y_s = pd.Series(y, name='target')

    # 3. Perform mRMR feature selection
    print(f"\nRunning mRMR to select the top {k} most important features...")
    # This function returns a list of the *names* of the selected features
    selected_feature_names = mrmr_classif(X=X_df, y=y_s, K=k)
    print("mRMR selection complete.")
    
    # 4. Convert selected feature names back to their original integer indices
    # This is the crucial information we need to save.
    selected_indices = [feature_names.index(name) for name in selected_feature_names]
    
    print(f"\nTop {k} selected feature names: {selected_feature_names}")
    print(f"Corresponding feature indices (0-285): {selected_indices}")

    # 5. Save the list of selected indices to a file
    # This is the "Feature_Select" model file for future use.
    # Using joblib is robust for saving Python objects.
    print(f"\nSaving the list of {k} selected indices to '{SELECTED_INDICES_FILE}'...")
    joblib.dump(selected_indices, SELECTED_INDICES_FILE)
    print("-> Indices saved successfully.")

    # 6. Create and save the new, reduced dataset for the next step (SVM training)
    X_selected = X_full[:, selected_indices]
    print(f"\nCreated a new, reduced feature matrix with shape: {X_selected.shape}")
    print(f"Saving this reduced dataset to '{REDUCED_DATASET_FILE}'...")
    np.save(REDUCED_DATASET_FILE, X_selected)
    print("-> Reduced dataset saved successfully.")
    
    print("\n--- Feature Selection process is complete! ---")
    print(f"You can now use '{REDUCED_DATASET_FILE}' to train your SVM.")


if __name__ == '__main__':
    select_and_save_best_features(k=NUM_FEATURES_TO_SELECT)